/**
 * Automated Penetration Testing Suite
 * Comprehensive automated penetration testing for web applications
 */

import { test, expect } from '@playwright/test';
import { SECURITY_CONFIG } from '../config/security-config.js';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

export class AutomatedPenetrationTester {
  constructor(page, options = {}) {
    this.page = page;
    this.config = { ...SECURITY_CONFIG, ...options };
    this.testResults = [];
    this.sessionTokens = new Map();
    this.baseUrl = this.config.environments.development.baseUrl;
    this.apiUrl = this.config.environments.development.apiUrl;
  }

  /**
   * Run complete penetration testing suite
   */
  async runPenetrationTests() {
    console.log('🎯 Starting automated penetration testing...');
    
    const testSuites = [
      () => this.testAuthenticationBypass(),
      () => this.testSessionManagement(),
      () => this.testPrivilegeEscalation(),
      () => this.testBusinessLogicFlaws(),
      () => this.testInjectionVulnerabilities(),
      () => this.testAccessControls(),
      () => this.testCryptographicFlaws(),
      () => this.testSecurityMisconfigurations()
    ];

    for (const testSuite of testSuites) {
      try {
        await testSuite();
      } catch (error) {
        console.error(`Penetration test failed: ${error.message}`);
        this.addResult('ERROR', 'test-failure', error.message);
      }
    }

    return this.generatePenetrationReport();
  }

  /**
   * Test authentication bypass vulnerabilities
   */
  async testAuthenticationBypass() {
    console.log('🔐 Testing authentication bypass attacks...');

    await this.testSQLInjectionLogin();
    
    await this.testHeaderBasedBypass();
    
    await this.testJWTTokenManipulation();
    
    await this.testSessionFixation();
    
    await this.testPasswordResetFlaws();
  }

  /**
   * Test SQL injection in login forms
   */
  async testSQLInjectionLogin() {
    const sqlPayloads = [
      "admin'--",
      "admin'/*",
      "' OR '1'='1",
      "' OR '1'='1'--",
      "' OR '1'='1'/*",
      "') OR ('1'='1",
      "') OR ('1'='1'--",
      "admin'; DROP TABLE users;--",
      "1' OR '1'='1' UNION SELECT null, username, password FROM users--"
    ];

    await this.page.goto('/login');

    for (const payload of sqlPayloads) {
      try {
        await this.page.fill('[data-testid="email-input"]', payload);
        await this.page.fill('[data-testid="password-input"]', 'password');
        await this.page.click('[data-testid="signin-button"]');
        
        await this.page.waitForTimeout(2000);
        
        const isLoggedIn = await this.isUserLoggedIn();
        const hasErrorMessage = await this.page.locator('[data-testid="signin-error"]').isVisible();
        const hasDatabaseError = await this.page.locator('text=/database|sql|mysql|postgresql/i').isVisible();
        
        if (isLoggedIn) {
          this.addResult('CRITICAL', 'sql-injection-login', 
            `SQL injection successful with payload: ${payload}`, 
            { payload, url: '/login' });
        } else if (hasDatabaseError) {
          this.addResult('HIGH', 'sql-injection-error-disclosure',
            `Database error exposed with payload: ${payload}`,
            { payload, url: '/login' });
        }
        
        await this.page.goto('/login');
        
      } catch (error) {
        console.log(`SQL injection test with payload "${payload}" - no vulnerability detected`);
      }
    }
  }

  /**
   * Test authentication bypass via HTTP headers
   */
  async testHeaderBasedBypass() {
    const bypassHeaders = [
      { 'X-User-Id': 'admin' },
      { 'X-Forwarded-User': 'admin' },
      { 'X-Remote-User': 'admin' },
      { 'X-Original-User': 'admin' },
      { 'User': 'admin' },
      { 'Username': 'admin' },
      { 'X-Authenticated': 'true' },
      { 'X-Auth-User': 'admin' },
      { 'Authorization': 'Bearer admin' },
      { 'X-Real-IP': '127.0.0.1' },
      { 'X-Forwarded-For': '127.0.0.1' },
      { 'Client-IP': '127.0.0.1' }
    ];

    const protectedEndpoints = [
      '/dashboard',
      '/admin',
      '/api/users/profile',
      '/api/admin/users'
    ];

    for (const endpoint of protectedEndpoints) {
      for (const headers of bypassHeaders) {
        try {
          const response = await this.page.request.get(`${this.baseUrl}${endpoint}`, {
            headers
          });

          if (response.ok()) {
            this.addResult('CRITICAL', 'header-based-auth-bypass',
              `Authentication bypassed using headers on ${endpoint}`,
              { headers, endpoint, status: response.status() });
          }
        } catch (error) {
        }
      }
    }
  }

  /**
   * Test JWT token manipulation
   */
  async testJWTTokenManipulation() {
    const token = await this.getValidJWTToken();
    
    if (!token) {
      console.log('No JWT token available for manipulation testing');
      return;
    }

    const manipulations = [
      () => this.testJWTNoneAlgorithm(token),
      () => this.testJWTAlgorithmConfusion(token),
      () => this.testJWTWeakSecret(token),
      () => this.testJWTPayloadManipulation(token)
    ];

    for (const manipulation of manipulations) {
      await manipulation();
    }
  }

  /**
   * Test JWT None Algorithm vulnerability
   */
  async testJWTNoneAlgorithm(originalToken) {
    try {
      const [header, payload, signature] = originalToken.split('.');
      const decodedHeader = JSON.parse(atob(header));
      const decodedPayload = JSON.parse(atob(payload));

      decodedHeader.alg = 'none';
      
      if (decodedPayload.role) {
        decodedPayload.role = 'admin';
      }
      if (decodedPayload.permissions) {
        decodedPayload.permissions = ['admin', 'read', 'write', 'delete'];
      }

      const manipulatedHeader = btoa(JSON.stringify(decodedHeader));
      const manipulatedPayload = btoa(JSON.stringify(decodedPayload));
      const manipulatedToken = `${manipulatedHeader}.${manipulatedPayload}.`;

      const response = await this.page.request.get(`${this.baseUrl}/api/users/profile`, {
        headers: { 'Authorization': `Bearer ${manipulatedToken}` }
      });

      if (response.ok()) {
        this.addResult('CRITICAL', 'jwt-none-algorithm',
          'JWT token accepted with "none" algorithm',
          { originalToken: originalToken.substring(0, 50) + '...', manipulatedToken: manipulatedToken.substring(0, 50) + '...' });
      }
    } catch (error) {
    }
  }

  /**
   * Test JWT algorithm confusion (RS256 to HS256)
   */
  async testJWTAlgorithmConfusion(originalToken) {
    try {
      const [header, payload, signature] = originalToken.split('.');
      const decodedHeader = JSON.parse(atob(header));
      const decodedPayload = JSON.parse(atob(payload));

      if (decodedHeader.alg === 'RS256') {
        decodedHeader.alg = 'HS256';
        
        const manipulatedHeader = btoa(JSON.stringify(decodedHeader));
        const manipulatedPayload = btoa(JSON.stringify(decodedPayload));
        
        const commonSecrets = ['secret', 'key', 'jwt', 'token', '123456'];
        
        for (const secret of commonSecrets) {
          try {
            const hmac = crypto.createHmac('sha256', secret);
            hmac.update(`${manipulatedHeader}.${manipulatedPayload}`);
            const newSignature = hmac.digest('base64url');
            
            const manipulatedToken = `${manipulatedHeader}.${manipulatedPayload}.${newSignature}`;
            
            const response = await this.page.request.get(`${this.baseUrl}/api/users/profile`, {
              headers: { 'Authorization': `Bearer ${manipulatedToken}` }
            });

            if (response.ok()) {
              this.addResult('CRITICAL', 'jwt-algorithm-confusion',
                `JWT algorithm confusion successful with secret: ${secret}`,
                { secret, manipulatedToken: manipulatedToken.substring(0, 50) + '...' });
            }
          } catch (error) {
          }
        }
      }
    } catch (error) {
    }
  }

  /**
   * Test JWT payload manipulation
   */
  async testJWTPayloadManipulation(originalToken) {
    try {
      const [header, payload, signature] = originalToken.split('.');
      const decodedPayload = JSON.parse(atob(payload));

      const manipulations = [
        () => ({ ...decodedPayload, role: 'admin' }),
        () => ({ ...decodedPayload, sub: '1', user_id: '1' }),
        () => ({ ...decodedPayload, permissions: ['admin', 'read', 'write', 'delete'] }),
        () => ({ ...decodedPayload, exp: Math.floor(Date.now() / 1000) + 3600 })
      ];

      for (const manipulation of manipulations) {
        const manipulatedPayload = btoa(JSON.stringify(manipulation()));
        const manipulatedToken = `${header}.${manipulatedPayload}.${signature}`;

        const response = await this.page.request.get(`${this.baseUrl}/api/users/profile`, {
          headers: { 'Authorization': `Bearer ${manipulatedToken}` }
        });

        if (response.ok()) {
          this.addResult('HIGH', 'jwt-payload-manipulation',
            'JWT payload manipulation accepted without signature verification',
            { manipulation: manipulation.name, manipulatedToken: manipulatedToken.substring(0, 50) + '...' });
        }
      }
    } catch (error) {
    }
  }

  /**
   * Test session management vulnerabilities
   */
  async testSessionManagement() {
    console.log('🎫 Testing session management vulnerabilities...');

    await this.testSessionFixation();
    await this.testSessionHijacking();
    await this.testConcurrentSessions();
    await this.testSessionTimeout();
  }

  /**
   * Test session fixation vulnerability
   */
  async testSessionFixation() {
    await this.page.goto('/login');
    const preLoginCookies = await this.page.context().cookies();
    const preLoginSessionId = this.extractSessionId(preLoginCookies);

    if (preLoginSessionId) {
      await this.page.fill('[data-testid="email-input"]', 'test@example.com');
      await this.page.fill('[data-testid="password-input"]', 'TestPassword123!');
      await this.page.click('[data-testid="signin-button"]');

      await this.page.waitForTimeout(2000);

      const postLoginCookies = await this.page.context().cookies();
      const postLoginSessionId = this.extractSessionId(postLoginCookies);

      if (preLoginSessionId === postLoginSessionId) {
        this.addResult('HIGH', 'session-fixation',
          'Session ID not regenerated after login',
          { preLoginSessionId, postLoginSessionId });
      }
    }
  }

  /**
   * Test privilege escalation vulnerabilities
   */
  async testPrivilegeEscalation() {
    console.log('⬆️ Testing privilege escalation vulnerabilities...');

    await this.testHorizontalPrivilegeEscalation();
    await this.testVerticalPrivilegeEscalation();
    await this.testDirectObjectReferences();
  }

  /**
   * Test horizontal privilege escalation
   */
  async testHorizontalPrivilegeEscalation() {
    await this.loginAsUser('user');
    
    const testCases = [
      { endpoint: '/api/users/1/profile', method: 'GET' },
      { endpoint: '/api/users/2/profile', method: 'GET' },
      { endpoint: '/api/users/1/settings', method: 'PUT', data: { theme: 'dark' } },
      { endpoint: '/api/appointments/user/2', method: 'GET' },
      { endpoint: '/api/payments/user/1', method: 'GET' }
    ];

    for (const testCase of testCases) {
      try {
        const options = {
          headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
        };
        
        if (testCase.data) {
          options.data = testCase.data;
        }

        const response = await this.page.request[testCase.method.toLowerCase()](`${this.baseUrl}${testCase.endpoint}`, options);

        if (response.ok()) {
          this.addResult('HIGH', 'horizontal-privilege-escalation',
            `Access granted to other user's resource: ${testCase.endpoint}`,
            { endpoint: testCase.endpoint, method: testCase.method });
        }
      } catch (error) {
      }
    }
  }

  /**
   * Test vertical privilege escalation
   */
  async testVerticalPrivilegeEscalation() {
    await this.loginAsUser('user');
    
    const adminEndpoints = [
      { endpoint: '/api/admin/users', method: 'GET' },
      { endpoint: '/api/admin/settings', method: 'GET' },
      { endpoint: '/api/admin/logs', method: 'GET' },
      { endpoint: '/api/admin/users/1', method: 'DELETE' },
      { endpoint: '/admin/dashboard', method: 'GET' }
    ];

    for (const testCase of adminEndpoints) {
      try {
        const response = await this.page.request[testCase.method.toLowerCase()](`${this.baseUrl}${testCase.endpoint}`, {
          headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
        });

        if (response.ok()) {
          this.addResult('CRITICAL', 'vertical-privilege-escalation',
            `Regular user accessed admin endpoint: ${testCase.endpoint}`,
            { endpoint: testCase.endpoint, method: testCase.method });
        }
      } catch (error) {
      }
    }
  }

  /**
   * Test business logic flaws
   */
  async testBusinessLogicFlaws() {
    console.log('💼 Testing business logic vulnerabilities...');

    await this.testPriceManipulation();
    await this.testWorkflowBypass();
    await this.testRateLimitBypass();
    await this.testDataValidationBypass();
  }

  /**
   * Test price manipulation vulnerabilities
   */
  async testPriceManipulation() {
    const manipulationTests = [
      { price: -100, description: 'negative price' },
      { price: 0, description: 'zero price' },
      { price: 0.01, description: 'minimal price' },
      { price: 999999999, description: 'extremely high price' },
      { price: 'NaN', description: 'non-numeric price' },
      { price: null, description: 'null price' },
      { price: undefined, description: 'undefined price' }
    ];

    for (const test of manipulationTests) {
      try {
        const response = await this.page.request.post(`${this.baseUrl}/api/bookings/create`, {
          data: {
            service_id: 1,
            date: '2024-12-31',
            time: '10:00',
            price: test.price
          },
          headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
        });

        if (response.ok()) {
          const result = await response.json();
          this.addResult('HIGH', 'price-manipulation',
            `Price manipulation accepted: ${test.description}`,
            { testPrice: test.price, response: result });
        }
      } catch (error) {
      }
    }
  }

  /**
   * Test injection vulnerabilities comprehensively
   */
  async testInjectionVulnerabilities() {
    console.log('💉 Testing injection vulnerabilities...');

    await this.testSQLInjection();
    await this.testNoSQLInjection();
    await this.testLDAPInjection();
    await this.testCommandInjection();
    await this.testTemplateInjection();
  }

  /**
   * Test NoSQL injection vulnerabilities
   */
  async testNoSQLInjection() {
    const nosqlPayloads = this.config.inputValidation.nosqlInjectionPatterns;
    
    const testEndpoints = [
      '/api/users/search',
      '/api/bookings/search',
      '/api/analytics/query'
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of nosqlPayloads) {
        try {
          const response = await this.page.request.post(`${this.baseUrl}${endpoint}`, {
            data: { query: payload },
            headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
          });

          const responseText = await response.text();
          
          if (response.ok() && responseText.includes('admin')) {
            this.addResult('CRITICAL', 'nosql-injection',
              `NoSQL injection successful on ${endpoint}`,
              { payload, endpoint });
          }
        } catch (error) {
        }
      }
    }
  }

  /**
   * Test LDAP injection vulnerabilities
   */
  async testLDAPInjection() {
    const ldapPayloads = this.config.inputValidation.ldapInjectionPatterns;
    
    const testEndpoints = [
      '/api/auth/ldap',
      '/api/users/ldap-search'
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of ldapPayloads) {
        try {
          const response = await this.page.request.post(`${this.baseUrl}${endpoint}`, {
            data: { username: payload },
            headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
          });

          if (response.ok()) {
            this.addResult('HIGH', 'ldap-injection',
              `LDAP injection successful on ${endpoint}`,
              { payload, endpoint });
          }
        } catch (error) {
        }
      }
    }
  }

  /**
   * Test access control vulnerabilities
   */
  async testAccessControls() {
    console.log('🚪 Testing access control vulnerabilities...');

    await this.testDirectObjectReferences();
    await this.testForcedBrowsing();
    await this.testMethodBypass();
  }

  /**
   * Test direct object reference vulnerabilities
   */
  async testDirectObjectReferences() {
    const resourceTests = [
      { resource: 'users', ids: ['1', '2', '999', 'admin', '../admin', '../../etc/passwd'] },
      { resource: 'documents', ids: ['1', '2', '999', '../config', '../../.env'] },
      { resource: 'files', ids: ['1', '2', '999', '../uploads', '../../secret.key'] }
    ];

    for (const test of resourceTests) {
      for (const id of test.ids) {
        try {
          const response = await this.page.request.get(`${this.baseUrl}/api/${test.resource}/${id}`, {
            headers: { 'Authorization': `Bearer ${this.sessionTokens.get('user')}` }
          });

          if (response.ok()) {
            const responseText = await response.text();
            
            const sensitivePatterns = [
              /password/i,
              /secret/i,
              /key/i,
              /token/i,
              /admin/i,
              /root:/,
              /etc\/passwd/
            ];

            const hasSensitiveInfo = sensitivePatterns.some(pattern => pattern.test(responseText));
            
            if (hasSensitiveInfo) {
              this.addResult('HIGH', 'direct-object-reference',
                `Direct object reference vulnerability: ${test.resource}/${id}`,
                { resource: test.resource, id, responsePreview: responseText.substring(0, 200) });
            }
          }
        } catch (error) {
        }
      }
    }
  }

  /**
   * Test cryptographic implementation flaws
   */
  async testCryptographicFlaws() {
    console.log('🔐 Testing cryptographic vulnerabilities...');

    await this.testWeakEncryption();
    await this.testInsecureRandomness();
    await this.testCertificateValidation();
  }

  /**
   * Test weak encryption implementations
   */
  async testWeakEncryption() {
    try {
      const response = await fetch(this.baseUrl.replace('https://', 'http://'));
      
      if (response.ok) {
        this.addResult('HIGH', 'insecure-transport',
          'Application accepts HTTP connections',
          { url: this.baseUrl.replace('https://', 'http://') });
      }
    } catch (error) {
    }

    this.addResult('INFO', 'crypto-review-needed',
      'Manual review needed for SSL/TLS cipher suite strength',
      { recommendation: 'Use tools like SSL Labs or testssl.sh for comprehensive SSL analysis' });
  }

  /**
   * Helper methods
   */
  
  async getValidJWTToken() {
    try {
      await this.loginAsUser('user');
      return this.sessionTokens.get('user');
    } catch (error) {
      return null;
    }
  }

  async loginAsUser(userType) {
    const users = this.config.penetrationTesting.scope.testUsers;
    const user = users[userType];
    
    if (!user) {
      throw new Error(`Test user ${userType} not configured`);
    }

    await this.page.goto('/login');
    await this.page.fill('[data-testid="email-input"]', user.email);
    await this.page.fill('[data-testid="password-input"]', user.password);
    await this.page.click('[data-testid="signin-button"]');
    
    await this.page.waitForTimeout(2000);
    
    const token = await this.page.evaluate(() => {
      return localStorage.getItem('token') || sessionStorage.getItem('token');
    });
    
    if (token) {
      this.sessionTokens.set(userType, token);
    }
    
    return token;
  }

  async isUserLoggedIn() {
    const currentUrl = this.page.url();
    const hasAuthCookie = (await this.page.context().cookies()).some(c => 
      c.name.includes('auth') || c.name.includes('session') || c.name.includes('token')
    );
    const hasDashboardElements = await this.page.locator('[data-testid="dashboard"]').isVisible();
    
    return currentUrl.includes('/dashboard') || hasAuthCookie || hasDashboardElements;
  }

  extractSessionId(cookies) {
    const sessionCookie = cookies.find(c => 
      c.name.includes('session') || c.name.includes('connect.sid') || c.name.includes('JSESSIONID')
    );
    return sessionCookie ? sessionCookie.value : null;
  }

  addResult(severity, category, description, details = {}) {
    this.testResults.push({
      timestamp: new Date().toISOString(),
      severity,
      category,
      description,
      details
    });
    
    console.log(`[${severity}] ${category}: ${description}`);
  }

  /**
   * Generate comprehensive penetration testing report
   */
  async generatePenetrationReport() {
    const summary = {
      totalTests: this.testResults.length,
      critical: this.testResults.filter(r => r.severity === 'CRITICAL').length,
      high: this.testResults.filter(r => r.severity === 'HIGH').length,
      medium: this.testResults.filter(r => r.severity === 'MEDIUM').length,
      low: this.testResults.filter(r => r.severity === 'LOW').length,
      info: this.testResults.filter(r => r.severity === 'INFO').length
    };

    const report = {
      scanId: `pentest_${Date.now()}`,
      timestamp: new Date().toISOString(),
      summary,
      findings: this.testResults,
      recommendations: this.generatePentestRecommendations()
    };

    console.log('📊 Penetration Testing Summary:');
    console.log(`🔴 Critical: ${summary.critical}`);
    console.log(`🟠 High: ${summary.high}`);
    console.log(`🟡 Medium: ${summary.medium}`);
    console.log(`🟢 Low: ${summary.low}`);
    console.log(`ℹ️ Info: ${summary.info}`);

    return report;
  }

  generatePentestRecommendations() {
    const recommendations = [];
    
    this.testResults.forEach(result => {
      switch (result.category) {
        case 'sql-injection-login':
          recommendations.push({
            priority: 'CRITICAL',
            category: 'Input Validation',
            recommendation: 'Implement parameterized queries and input validation for all user inputs',
            cwe: 'CWE-89'
          });
          break;
        case 'jwt-none-algorithm':
          recommendations.push({
            priority: 'CRITICAL',
            category: 'Authentication',
            recommendation: 'Reject JWT tokens with "none" algorithm and implement proper algorithm validation',
            cwe: 'CWE-287'
          });
          break;
        case 'privilege-escalation':
          recommendations.push({
            priority: 'HIGH',
            category: 'Access Control',
            recommendation: 'Implement proper role-based access control and authorization checks',
            cwe: 'CWE-269'
          });
          break;
      }
    });

    return recommendations.slice(0, 20); // Top 20 recommendations
  }
}

export default AutomatedPenetrationTester;